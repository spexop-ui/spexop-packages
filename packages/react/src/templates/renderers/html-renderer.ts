/**
 * HTML + CSS Template Renderer
 * Generates semantic HTML with standalone CSS
 */

import type { SpexopThemeConfig } from "@spexop/theme";
import { generateCSS } from "@spexop/theme";
import type { Template, TemplateNode } from "../types.js";

/**
 * Render template to HTML and CSS
 */
export function renderTemplateToHTML(
  template: Template,
  theme: SpexopThemeConfig,
  customProps: Record<string, unknown> = {},
): { html: string; css: string } {
  // Apply custom props to root structure
  const customizedStructure = {
    ...template.structure,
    props: {
      ...template.structure.props,
      ...customProps,
    },
  };

  // Generate CSS from theme
  const css = generateCSS(theme);

  // Generate HTML
  const bodyContent = renderNodeToHTML(customizedStructure, 1);

  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${template.meta.name}</title>
  <meta name="description" content="${template.meta.description}">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <!-- ${template.meta.name} -->
  <!-- Generated by Spexop Builder -->
  <!-- 
    Note: This is a semantic HTML version. 
    For the best experience, use @spexop/react components in your React app.
    Visit https://spexop.com for full component library.
  -->
${bodyContent}
</body>
</html>`;

  return { html, css };
}

/**
 * Render a node to HTML
 */
function renderNodeToHTML(node: TemplateNode, indentLevel: number): string {
  const { type, props = {}, children, content } = node;
  const indent = "  ".repeat(indentLevel);

  switch (type) {
    case "Container":
      return renderContainer(props, children, indentLevel, indent);

    case "Grid":
      return renderGrid(props, children, indentLevel, indent);

    case "GridItem":
      return renderGridItem(props, children, indentLevel, indent);

    case "Stack":
      return renderStack(props, children, indentLevel, indent);

    case "Spacer":
      return `${indent}<div class="spacer" style="height: var(--s-spacing-${
        props.size || 4
      })"></div>\n`;

    case "Button":
      return renderButton(props, content, indent);

    case "Card":
      return renderCard(props, children, indentLevel, indent);

    case "Heading":
      return renderHeading(props, content, indent);

    case "Text":
      return `${indent}<p${formatHTMLProps(props)}>${content || ""}</p>\n`;

    case "Section":
    case "div":
      return renderDiv(props, children, content, indentLevel, indent);

    default:
      return renderDiv(props, children, content, indentLevel, indent);
  }
}

/**
 * Render Container as div with container class
 */
function renderContainer(
  props: Record<string, unknown>,
  children: TemplateNode[] | undefined,
  indentLevel: number,
  indent: string,
): string {
  const maxWidth = props.maxWidth || "2xl";
  const padding = props.padding || 6;
  const style = `max-width: var(--s-breakpoint-${maxWidth}); margin: 0 auto; padding: var(--s-spacing-${padding});`;

  const opening = `${indent}<div class="container" style="${style}">`;
  const closing = `${indent}</div>`;

  if (!children || children.length === 0) {
    return `${opening}${closing}\n`;
  }

  const childrenHTML = children
    .map((child) => renderNodeToHTML(child, indentLevel + 1))
    .join("");

  return `${opening}\n${childrenHTML}${closing}\n`;
}

/**
 * Render Grid as div with CSS Grid
 */
function renderGrid(
  props: Record<string, unknown>,
  children: TemplateNode[] | undefined,
  indentLevel: number,
  indent: string,
): string {
  const columns = props.columns || 12;
  const gap = props.gap || 6;
  const minColumnWidth = props.minColumnWidth || "250px";

  let gridTemplate = "";
  if (columns === "auto-fit") {
    gridTemplate = `repeat(auto-fit, minmax(${minColumnWidth}, 1fr))`;
  } else {
    gridTemplate = `repeat(${columns}, 1fr)`;
  }

  const style = `display: grid; grid-template-columns: ${gridTemplate}; gap: var(--s-spacing-${gap});`;

  const opening = `${indent}<div class="grid" style="${style}">`;
  const closing = `${indent}</div>`;

  if (!children || children.length === 0) {
    return `${opening}${closing}\n`;
  }

  const childrenHTML = children
    .map((child) => renderNodeToHTML(child, indentLevel + 1))
    .join("");

  return `${opening}\n${childrenHTML}${closing}\n`;
}

/**
 * Render GridItem as div with grid column span
 */
function renderGridItem(
  props: Record<string, unknown>,
  children: TemplateNode[] | undefined,
  indentLevel: number,
  indent: string,
): string {
  const span = props.span || 1;
  const style = `grid-column: span ${span};`;

  const opening = `${indent}<div class="grid-item" style="${style}">`;
  const closing = `${indent}</div>`;

  if (!children || children.length === 0) {
    return `${opening}${closing}\n`;
  }

  const childrenHTML = children
    .map((child) => renderNodeToHTML(child, indentLevel + 1))
    .join("");

  return `${opening}\n${childrenHTML}${closing}\n`;
}

/**
 * Render Stack as flex container
 */
function renderStack(
  props: Record<string, unknown>,
  children: TemplateNode[] | undefined,
  indentLevel: number,
  indent: string,
): string {
  const direction = props.direction || "vertical";
  const gap = props.gap || 4;
  const align = props.align || "stretch";
  const justify = props.justify || "flex-start";

  const flexDirection = direction === "vertical" ? "column" : "row";
  const style = `display: flex; flex-direction: ${flexDirection}; gap: var(--s-spacing-${gap}); align-items: ${align}; justify-content: ${justify};`;

  const opening = `${indent}<div class="stack" style="${style}">`;
  const closing = `${indent}</div>`;

  if (!children || children.length === 0) {
    return `${opening}${closing}\n`;
  }

  const childrenHTML = children
    .map((child) => renderNodeToHTML(child, indentLevel + 1))
    .join("");

  return `${opening}\n${childrenHTML}${closing}\n`;
}

/**
 * Render Button
 */
function renderButton(
  props: Record<string, unknown>,
  content: string | undefined,
  indent: string,
): string {
  const variant = props.variant || "primary";
  const size = props.size || "medium";
  return `${indent}<button class="button button-${variant} button-${size}">${
    content || "Button"
  }</button>\n`;
}

/**
 * Render Card
 */
function renderCard(
  props: Record<string, unknown>,
  children: TemplateNode[] | undefined,
  indentLevel: number,
  indent: string,
): string {
  const padding = props.padding || 6;
  const style = `padding: var(--s-spacing-${padding}); border: 1px solid var(--s-color-border); border-radius: var(--s-border-radius-relaxed); background: var(--s-color-surface);`;

  const opening = `${indent}<div class="card" style="${style}">`;
  const closing = `${indent}</div>`;

  if (!children || children.length === 0) {
    return `${opening}${closing}\n`;
  }

  const childrenHTML = children
    .map((child) => renderNodeToHTML(child, indentLevel + 1))
    .join("");

  return `${opening}\n${childrenHTML}${closing}\n`;
}

/**
 * Render Heading
 */
function renderHeading(
  props: Record<string, unknown>,
  content: string | undefined,
  indent: string,
): string {
  const level = props?.level || 2;
  const tag = `h${level}`;
  const { level: _, ...restProps } = props || {};
  const propsString = formatHTMLProps(restProps);
  return `${indent}<${tag}${propsString}>${content || ""}</${tag}>\n`;
}

/**
 * Render div
 */
function renderDiv(
  props: Record<string, unknown>,
  children: TemplateNode[] | undefined,
  content: string | undefined,
  indentLevel: number,
  indent: string,
): string {
  const propsString = formatHTMLProps(props);
  const opening = `${indent}<div${propsString}>`;
  const closing = `${indent}</div>`;

  if (content && !children) {
    return `${opening}${content}${closing}\n`;
  }

  if (!children || children.length === 0) {
    return `${opening}${closing}\n`;
  }

  const childrenHTML = children
    .map((child) => renderNodeToHTML(child, indentLevel + 1))
    .join("");

  return `${opening}\n${childrenHTML}${closing}\n`;
}

/**
 * Format props to HTML attributes
 */
function formatHTMLProps(props: Record<string, unknown>): string {
  if (!props || Object.keys(props).length === 0) return "";

  return Object.entries(props)
    .map(([key, value]) => {
      if (key === "style" && typeof value === "object" && value !== null) {
        const styleString = Object.entries(value as Record<string, unknown>)
          .map(([k, v]) => `${k}: ${v}`)
          .join("; ");
        return ` style="${styleString}"`;
      }

      if (typeof value === "string") {
        return ` ${key}="${value}"`;
      }

      return "";
    })
    .filter(Boolean)
    .join("");
}
